// This code is auto-generated by Qul's qmltocpp tool.
// WARNING! All changes made in this file will be lost!
#include "hmimain.h"


#include <qul/private/unicodestring.h>
#include <qul/private/file.h>
#include <qul/private/items/itembase.h>


struct LoaderItemAppRelativePathCallbackItemData {
    LoaderItemAppRelativePathCallbackItemData()
        : item(NULL)
    {
    }

    Qul::Private::Items::ItemBase *item;
};

static bool loaderItemAppRelativePathCallback(const Qul::Private::String &relativePath, void *data)
{
    LoaderItemAppRelativePathCallbackItemData *d = static_cast<LoaderItemAppRelativePathCallbackItemData *>(data);

    Qul::PlatformInterface::MemoryAllocator *allocator = Qul::Platform::getPlatformInstance()->memoryAllocator(Qul::PlatformInterface::MemoryAllocator::QmlDynamicObjects);

        if (relativePath == Qul::Private::String(Qul::Private::Latin1String("qml/hmimain.qml", 15))) {
            hmimain *element = static_cast<hmimain *>(allocator->allocate(sizeof(hmimain)));

            if(!element)
                return false;

            new (element) hmimain();
            d->item = element;
        }


    if (d->item)
        return true;

    Qul::PlatformInterface::log("failed to load item from: %s\n", relativePath.maybeUtf8());
    return false;
}

Qul::Private::Items::ItemBase *loaderItemAllocator(const Qul::Private::String &uri, const Qul::Private::String &currentFileDir)
{
    if (uri.isEmpty())
        return NULL;

    LoaderItemAppRelativePathCallbackItemData loaderData;

    bool ok = Qul::Private::appRelativePath(uri, currentFileDir, loaderItemAppRelativePathCallback, &loaderData);
    QUL_UNUSED(ok);

    return loaderData.item;
}

